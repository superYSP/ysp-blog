## JavaSE_第8章 异常

### 1 认识Java的异常

### 1、什么是异常

在使用计算机语言进行项目开发的过程中，即使程序员把代码写得尽善尽美，在系统的运行过程中仍然会遇到一些问题，因为很多问题不是靠代码能够避免的，比如：客户输入数据的格式问题，读取文件是否存在，网络是否始终保持通畅等等。

- **异常** ：指的是程序在执行过程中，出现的非正常的情况，如果不处理最终会导致JVM的非正常停止。

> 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.
> 异常也不是指逻辑代码错误而没有得到想要的结果，例如：求a与b的和，你写成了a-b

### 2、如何对待异常

程序员在编写程序时，就应该充分考虑到各种可能发生的异常和错误，极力预防和避免，实在无法避免的，要编写相应的代码进行异常的检测、异常消息的提示，以及异常的处理。

### 3、异常的抛出机制

Java中是如何表示不同的异常情况，又是如何==让程序员得知==，并==处理异常==的呢？

Java中把不同的异常用不同的类表示，一旦发生某种异常，就通过创建该异常类型的对象，并且抛出，然后程序员可以catch到这个异常对象，并处理，如果无法catch到这个异常对象，那么这个异常对象将会导致程序终止。

运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生和抛出的过程。

### 2 Java异常体系

### 1、Throwable

`java.lang.Throwable` 类是 Java 语言中所有错误或异常的超类。

- 只有当对象是此类（或其子类之一）的实例时，才能通过 Java 虚拟机或者 Java 的`throw` 语句抛出。类似地，只有此类或其子类之一才可以是 `catch` 子句中的参数类型。

### 2、Error和Exception

`Throwable`有两个直接子类：`java.lang.Error`与`java.lang.Exception`，平常所说的异常指`java.lang.Exception`。

- **Error**：表示严重错误，一旦发生必须停下来查看问题并解决问题才能继续，无法仅仅通过try...catch解决的错误。（如果拿生病做比喻，就像是突发疾病，而且是危重症，必须立刻停下来治疗而不是靠短暂休息、吃药、打针、或小手术简单解决处理）
- 例如：StackOverflowError（栈内存溢出）和OutOfMemoryError（堆内存溢出，简称OOM）。
- **Exception**：表示普通异常，其它因编程错误或偶然的外在因素导致的一般性问题，程序员可以通过代码的方式检测、提示和纠正，使程序继续运行，但是只要发生也是必须处理，否则程序也会挂掉。（这就好比普通感冒、阑尾炎、牙疼等，可以通过短暂休息、吃药、打针、或小手术简单解决，但是也不能搁置不处理，不然也会要人命）。
- 例如：空指针访问、试图读取不存在的文件、网络连接中断、数组下标越界等

### 3 受检异常和非受检异常

我们平常说的异常就是指Exception，根据代码的编写编译阶段，编译器是否会**警示**当前代码可能发生xx异常，并**督促**程序员提前编写处理它的代码为依据，可以将异常分为：

- **编译时期异常**（即checked异常、受检异常）：在代码编译阶段，编译器就能明确**警示**当前代码**可能发生（不是一定发生）**xx异常，并**督促**程序员提前编写处理它的代码。如果程序员**不听话**，没有编写对应的异常处理代码，则编译器就会**发威**，直接判定编译失败，从而程序无法执行。通常，这类异常的发生不是由程序员的代码引起的，或者不是靠加简单判断就可以避免的，例如：FileNotFoundException（文件找不到异常）。
- **运行时期异常**（即runtime异常、unchecked非受检异常）：即在代码编译阶段，编译器完全不做任何检查，无论该异常是否会发生，编译器都不给出任何提示。只有等代码运行起来并确实发生了xx异常，它才能被发现。通常，这类异常是由程序员的代码编写不当引起的，只要稍加判断，或者细心检查就可以避免的。例如：ArrayIndexOutOfBoundsException数组下标越界异常，ClassCastException类型转换异常。

### 4 捕获异常try…catch

### 1、try...catch基本格式

捕获异常语法如下：

```java
try{
     可能发生xx异常的代码
}catch(异常类型1  e){
     处理异常的代码1
}catch(异常类型2  e){
     处理异常的代码2
}
....
```

try{}中编写可能发生xx异常的业务逻辑代码。

catch分支，分为两个部分，catch()中编写异常类型和异常参数名，{}中编写如果发生了这个异常，要做什么处理的代码。如果有多个catch分支，并且多个异常类型有父子类关系，必须保证小的子异常类型在上，大的父异常类型在下。

当某段代码可能发生异常，不管这个异常是编译时异常（受检异常）还是运行时异常（非受检异常），我们都可以使用try块将它括起来，并在try块下面编写catch分支尝试捕获对应的异常对象。

- 如果在程序运行时，try块中的代码没有发生异常，那么catch所有的分支都不执行。
- 如果在程序运行时，try块中的代码发生了异常，根据异常对象的类型，将从上到下选择第一个匹配的catch分支执行。此时try中发生异常的语句下面的代码将不执行，而整个try...catch之后的代码可以继续运行。
- 如果在程序运行时，try块中的代码发生了异常，但是所有catch分支都无法匹配（捕获）这个异常，那么JVM将会终止当前方法的执行，并把异常对象“抛”给调用者。如果调用者不处理，程序就挂了。

### 5 finally块

因为异常会引发程序跳转，从而会导致有些语句执行不到。而程序中有一些特定的代码无论异常是否发生，都需要执行。例如，IO流的关闭，数据库连接的断开等。这样的代码通常就会放到finally块中。

```java
try{

 }catch(...){

 }finally{
     无论try中是否发生异常，也无论catch是否捕获异常，也不管try和catch中是否有return语句，都一定会执行
 }

 或
  try{

 }finally{
     无论try中是否发生异常，也不管try中是否有return语句，都一定会执行。
 }
```

> 注意:finally不能单独使用。
> 当只有在try或者catch中调用退出JVM的相关方法，例如System.exit(0),此时finally才不会执行,否则finally永远会执行。

### 5 转换异常处理位置throws

### 1、throws编译时异常

如果在编写方法体的代码时，某句代码可能发生某个==编译时异常==，不处理编译不通过，但是在当前方法体中可能不适合处理或无法给出合理的处理方式，就可以通过throws在方法签名中声明该方法可能会发生xx异常，需要调用者处理。

**声明异常格式：**

```text
修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…{   }
```

### 6 异常throw

Java程序的执行过程中如出现异常，会生成一个异常类对象，该异常对象将被提交给Java运行时系统，这个过程称为抛出(throw)异常。异常对象的生成有两种方式：

- 由虚拟机自动生成：程序运行过程中，虚拟机检测到程序发生了问题，就会在后台自动创建一个对应异常类的实例对象并抛出——自动抛出。
- 由开发人员手动创建：new 异常类型(【实参列表】);，如果创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样，但是一旦throw抛出，就会对程序运行产生影响了。

**使用格式：**

```java
throw new 异常类名(参数);
```

### 7 自定义异常

**为什么需要自定义异常类:**

我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是核心类库中没有定义好的，此时我们需要根据自己业务的异常情况来定义异常类。例如年龄负数问题，考试成绩负数问题等等。

**异常类如何定义:**

1. 自定义一个编译时异常类型：自定义类 并继承`java.lang.Exception`。
2. 自定义一个运行时异常类型：自定义类 并继承`java.lang.RuntimeException`。

==注意==自定义的异常只能通过throw抛出。

**演示自定义异常：**

```java
package com.atguigu.define;

public class NotTriangleException extends Exception{
    public NotTriangleException() {
    }

    public NotTriangleException(String message) {
        super(message);
    }
}
```